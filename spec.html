<!DOCTYPE html>
<meta charset="utf-8">
<link rel="icon" href="favicon.ico">
<link href="ecmarkup.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="ecmarkup.js"></script>
<script>
  if (location.hostname.endsWith('.github.io') && location.protocol !== 'https:') {
    location.protocol = 'https:';
  }
</script>
<pre class=metadata>
  title: Optional Chaining
  status: proposal
  stage: 1
  location: https://claudepache.github.io/es-nil
  copyright: false
  contributors: Claude Pache, ECMA International
</pre>

<emu-clause id="sec-scope">
  <h1>Scope</h1>
  <p>This is the spec text proposal for introducing Optional Chaining feature (aka Null Propagation, aka Existential Operator) in ECMAScript.</p>

  <p>For the syntax, we use the `?.` token, with a lookahead at the level of the lexical grammar that allows to discriminate between `a?.b` (optional chaining) and `a?.3:0` (conditional operator, whose meaning cannot be changed due to backward compatibility constraints).</p>

  <p>Modified content are marked <ins>like this</ins>. In order to avoid distraction, we donâ€™t mark mere editorial amendments.</p>

</emu-clause>

<emu-clause id="sec-nil-reference">
  <h1>The Nil Reference</h1>

    <!-- es6num="6.2.3" -->
    <emu-clause id="sec-reference-specification-type">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-reference-specification-type">6.2.4</a>) The Reference Specification Type</h1>
      <emu-note>
        <p>The Reference type is used to explain the behaviour of such operators as `delete`, `typeof`, the assignment operators, the `super` keyword and other language features. For example, the left-hand operand of an assignment is expected to produce a reference.</p>
      </emu-note>
      <p>A <dfn>Reference</dfn> is a resolved name or property binding. A Reference consists of three components, the base value component, the referenced name component, and the Boolean-valued strict reference flag. The base value component is either *undefined*, an Object, a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value component of *undefined* indicates that the Reference could not be resolved to a binding. The referenced name component is a String or Symbol value.</p>
      <p>A <dfn id="super-reference">Super Reference</dfn> is a Reference that is used to represents a name binding that was expressed using the super keyword. A Super Reference has an additional thisValue component, and its base value component will never be an Environment Record.</p>
      <p><ins>A <dfn id="nil-reference">Nil Reference</dfn> is a special Reference that is used to propagate an *undefined* value that is produced by the optional chaining special form (`?.`). A Nil Reference has only one component, the base value component, which is always equal to the symbol ~Nil~.</ins></p>
      <p>The following abstract operations are used in this specification to operate on references:</p>

      <emu-clause id="sec-getbase" aoid="GetBase">
        <h1 id="ao-getbase">GetBase ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. Return the base value component of _V_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getreferencedname" aoid="GetReferencedName">
        <h1 id="ao-getreferencedname">GetReferencedName ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. <ins>Assert: IsNilReference(_V_) is false.</ins>
          1. Return the referenced name component of _V_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isstrictreference" aoid="IsStrictReference">
        <h1 id="ao-isstrictreference">IsStrictReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. <ins>Assert: IsNilReference(_V_) is false.</ins>
          1. Return the strict reference flag of _V_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hasprimitivebase" aoid="HasPrimitiveBase">
        <h1 id="ao-hasprimitivebase">HasPrimitiveBase ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If Type(_V_'s base value component) is Boolean, String, Symbol, or Number, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ispropertyreference" aoid="IsPropertyReference">
        <h1 id="ao-ispropertyreference">IsPropertyReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If either the base value component of _V_ is an Object or HasPrimitiveBase(_V_) is *true*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunresolvablereference" aoid="IsUnresolvableReference">
        <h1 id="ao-isunresolvablereference">IsUnresolvableReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If the base value component of _V_ is *undefined*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issuperreference" aoid="IsSuperReference">
        <h1 id="ao-issuperreference">IsSuperReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If _V_ has a thisValue component, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <ins class="block">
      <emu-clause id="sec-isnilreference" aoid="IsNilReference">
        <h1 id="ao-issuperreference">IsNilReference ( _V_ )</h1>
        <emu-alg>
          1. Assert: Type(_V_) is Reference.
          1. If the base value component of _V_ is the symbol ~Nil~, return *true*; otherwise, return *false*.
        </emu-alg>
      </emu-clause>
      </ins>

      <!-- es6num="6.2.3.1" -->
      <emu-clause id="sec-getvalue" aoid="GetValue">
        <h1>GetValue ( _V_ )</h1>
        <emu-alg>
          1. ReturnIfAbrupt(_V_).
          1. If Type(_V_) is not Reference, return _V_.
          1. Let _base_ be GetBase(_V_).
          1. <ins>If IsNilReference(_V_) is *true*, return *undefined*.</ins>
          1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.
          1. If IsPropertyReference(_V_) is *true*, then
            1. If HasPrimitiveBase(_V_) is *true*, then
              1. Assert: In this case, _base_ will never be *undefined* or *null*.
              1. Set _base_ to ! ToObject(_base_).
            1. Return ? _base_.[[Get]](GetReferencedName(_V_), GetThisValue(_V_)).
          1. Else _base_ must be an Environment Record,
            1. Return ? _base_.GetBindingValue(GetReferencedName(_V_), IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
        </emu-alg>
        <emu-note>
          <p>The object that may be created in step 5.a.ii is not accessible outside of the above abstract operation and the ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>
        </emu-note>
      </emu-clause>

      <!-- es6num="6.2.3.2" -->
      <emu-clause id="sec-putvalue" aoid="PutValue">
        <h1>PutValue ( _V_, _W_ )</h1>
        <emu-alg>
          1. ReturnIfAbrupt(_V_).
          1. ReturnIfAbrupt(_W_).
          1. If Type(_V_) is not Reference, throw a *ReferenceError* exception.
          1. Let _base_ be GetBase(_V_).
          1. <ins>Assert: IsNilReference(_V_) is *false*.</ins>
          1. If IsUnresolvableReference(_V_) is *true*, then
            1. If IsStrictReference(_V_) is *true*, then
              1. Throw a *ReferenceError* exception.
            1. Let _globalObj_ be GetGlobalObject().
            1. Return ? Set(_globalObj_, GetReferencedName(_V_), _W_, *false*).
          1. Else if IsPropertyReference(_V_) is *true*, then
            1. If HasPrimitiveBase(_V_) is *true*, then
              1. Assert: In this case, _base_ will never be *undefined* or *null*.
              1. Set _base_ to ! ToObject(_base_).
            1. Let _succeeded_ be ? _base_.[[Set]](GetReferencedName(_V_), _W_, GetThisValue(_V_)).
            1. If _succeeded_ is *false* and IsStrictReference(_V_) is *true*, throw a *TypeError* exception.
            1. Return.
          1. Else _base_ must be an Environment Record,
            1. Return ? _base_.SetMutableBinding(GetReferencedName(_V_), _W_, IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
        </emu-alg>
        <emu-note>
          <p>The object that may be created in step 6.a.ii is not accessible outside of the above algorithm and the ordinary object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>
        </emu-note>
      </emu-clause>

      <!-- es6num="6.2.3.3" -->
      <emu-clause id="sec-getthisvalue" aoid="GetThisValue">
        <h1>GetThisValue ( _V_ )</h1>
        <emu-alg>
          1. Assert: IsPropertyReference(_V_) is *true*.
          1. If IsSuperReference(_V_) is *true*, then
            1. Return the value of the thisValue component of the reference _V_.
          1. Return GetBase(_V_).
        </emu-alg>
      </emu-clause>

      <!-- es6num="6.2.3.4" -->
      <emu-clause id="sec-initializereferencedbinding" aoid="InitializeReferencedBinding">
        <h1>InitializeReferencedBinding ( _V_, _W_ )</h1>
        <emu-alg>
          1. ReturnIfAbrupt(_V_).
          1. ReturnIfAbrupt(_W_).
          1. Assert: Type(_V_) is Reference.
          1. <ins>Assert: IsNilReference(_V_) is *false*.</ins>
          1. Assert: IsUnresolvableReference(_V_) is *false*.
          1. Let _base_ be GetBase(_V_).
          1. Assert: _base_ is an Environment Record.
          1. Return _base_.InitializeBinding(GetReferencedName(_V_), _W_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.4" -->
    <emu-clause id="sec-delete-operator">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-delete-operator">12.5.3</a>) The `delete` Operator</h1>

      <!-- es6num="12.5.4.1" -->
      <emu-clause id="sec-delete-operator-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the |UnaryExpression| is contained in strict mode code and the derived |UnaryExpression| is <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>.
          </li>
          <li>
            <p>It is a Syntax Error if the derived |UnaryExpression| is
              <br>
              <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
              <br>
              and |CoverParenthesizedExpressionAndArrowParameterList| ultimately derives a phrase that, if used in place of |UnaryExpression|, would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
          </li>
        </ul>
        <emu-note>
          <p>The last rule means that expressions such as `delete (((foo)))` produce early errors because of recursive application of the first rule.</p>
        </emu-note>
      </emu-clause>

      <!-- es6num="12.5.4.2" -->
      <emu-clause id="sec-delete-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _ref_ be the result of evaluating |UnaryExpression|.
          1. ReturnIfAbrupt(_ref_).
          1. If Type(_ref_) is not Reference, return *true*.
          1. <ins>If IsNilReference(_ref_) is *true*, return *true*.</ins>
          1. If IsUnresolvableReference(_ref_) is *true*, then
            1. Assert: IsStrictReference(_ref_) is *false*.
            1. Return *true*.
          1. If IsPropertyReference(_ref_) is *true*, then
            1. If IsSuperReference(_ref_) is *true*, throw a *ReferenceError* exception.
            1. Let _baseObj_ be ! ToObject(GetBase(_ref_)).
            1. Let _deleteStatus_ be ? _baseObj_.[[Delete]](GetReferencedName(_ref_)).
            1. If _deleteStatus_ is *false* and IsStrictReference(_ref_) is *true*, throw a *TypeError* exception.
            1. Return _deleteStatus_.
          1. Else _ref_ is a Reference to an Environment Record binding,
            1. Let _bindings_ be GetBase(_ref_).
            1. Return ? _bindings_.DeleteBinding(GetReferencedName(_ref_)).
        </emu-alg>
        <emu-note>
          <p>When a `delete` operator occurs within strict mode code, a *SyntaxError* exception is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name. In addition, if a `delete` operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: *false* }, a *TypeError* exception is thrown.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

  </emu-clause>

  <!-- es6num="11.7" -->
  <emu-clause id="sec-punctuators">
    <h1>(<a href="https://tc39.github.io/ecma262/#sec-punctuators">11.7</a>) Lexical Grammar: Punctuators</h1>
    <h2>Syntax</h2>
    <emu-grammar>
      <ins class="block">
      OptionalChainingOperator ::
        `?.` [lookahead &lt;! DecimalDigit
      </ins>

      OtherPunctuator :: one of
        `{` `(` `)` `[` `]`
        `.` `...` `;` `,`
        `&lt;` `&gt;` `&lt;=` `&gt;=`
        `==` `!=` `===` `!==`
        `+` `-` `*` `%` `**`
        `++` `--`
        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`
        `&amp;` `|` `^`
        `!` `~`
        `&amp;&amp;` `||`
        `?` `:`
        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`
        `=&gt;`

      Punctuator ::
        <ins>OptionalChainingOperator</ins>
        OtherPunctuator

      DivPunctuator ::
        `/`
        `/=`

      RightBracePunctuator ::
        `}`
    </emu-grammar>
  </emu-clause>

  <!-- es6num="12.2" -->
  <emu-clause id="sec-primary-expression">
    <h1>(<a href="https://tc39.github.io/ecma262/#sec-primary-expressions">12.2</a>) Primary Expression</h1>
    <h2>Syntax</h2>
    <emu-grammar>
      PrimaryExpression[Yield, Await] :
        `this`
        IdentifierReference[?Yield, ?Await]
        Literal
        ArrayLiteral[?Yield, ?Await]
        ObjectLiteral[?Yield, ?Await]
        FunctionExpression
        ClassExpression[?Yield, ?Await]
        GeneratorExpression
        AsyncFunctionExpression
        RegularExpressionLiteral
        TemplateLiteral[?Yield, ?Await]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `)`
        `(` `)`
        `(` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` `...` BindingPattern[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>When processing an instance of the production
      <br>
      <emu-grammar>PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar>
      <br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:</p>
    <emu-grammar>
      ParenthesizedExpression[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>

    <!-- es6num="12.2.1" -->
    <emu-clause id="sec-primary-expression-semantics">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-primary-expression-semantics">12.2.1</a>) Semantics</h1>

      <!-- es6num="12.2.1.1" -->
      <emu-clause id="sec-static-semantics-coveredparenthesizedexpression">
        <h1>Static Semantics: CoveredParenthesizedExpression</h1>
        <emu-grammar>CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] : `(` Expression[+In, ?Yield, ?Await] `)`</emu-grammar>
        <emu-alg>
          1. Return the result of parsing the lexical token stream matched by |CoverParenthesizedExpressionAndArrowParameterList| using |ParenthesizedExpression| as the goal symbol with its <sub>[Yield]</sub> and <sub>[Await]</sub> parameters set to the values used when parsing this |CoverParenthesizedExpressionAndArrowParameterList|.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.2.1.2" -->
      <emu-clause id="sec-semantics-static-semantics-hasname">
        <h1>Static Semantics: HasName</h1>
        <emu-see-also-para op="HasName"></emu-see-also-para>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. If IsFunctionDefinition of _expr_ is *false*, return *false*.
          1. Return HasName of _expr_.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.2.1.3" -->
      <emu-clause id="sec-semantics-static-semantics-isfunctiondefinition">
        <h1>Static Semantics: IsFunctionDefinition</h1>
        <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
        <emu-grammar>
          PrimaryExpression :
            `this`
            IdentifierReference
            Literal
            ArrayLiteral
            ObjectLiteral
            RegularExpressionLiteral
            TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return IsFunctionDefinition of _expr_.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.2.1.4" -->
      <emu-clause id="sec-semantics-static-semantics-isidentifierref">
        <h1>Static Semantics: IsIdentifierRef</h1>
        <emu-see-also-para op="IsIdentifierRef"></emu-see-also-para>
        <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>
          PrimaryExpression :
            `this`
            Literal
            ArrayLiteral
            ObjectLiteral
            FunctionExpression
            ClassExpression
            GeneratorExpression
            AsyncFunctionExpression
            RegularExpressionLiteral
            TemplateLiteral
            CoverParenthesizedExpressionAndArrowParameterList
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.2.1.5" -->
      <emu-clause id="sec-semantics-static-semantics-isvalidsimpleassignmenttarget">
        <h1>Static Semantics: IsValidSimpleAssignmentTarget</h1>
        <emu-see-also-para op="IsValidSimpleAssignmentTarget"></emu-see-also-para>
        <emu-grammar>
          PrimaryExpression :
            `this`
            Literal
            ArrayLiteral
            ObjectLiteral
            FunctionExpression
            ClassExpression
            GeneratorExpression
            AsyncFunctionExpression
            RegularExpressionLiteral
            TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return IsValidSimpleAssignmentTarget of _expr_.
        </emu-alg>
      </emu-clause>

      <ins class="block">
      <emu-clause id="sec-semantics-static-semantics-mayproducenil">
        <h1>Static Semantics: MayProduceNil</h1>
        <emu-see-also-para op="MayProduceNil"></emu-see-also-para>
        <emu-grammar>
          PrimaryExpression :
            `this`
            Literal
            ArrayLiteral
            ObjectLiteral
            FunctionExpression
            ClassExpression
            GeneratorExpression
            AsyncFunctionExpression
            RegularExpressionLiteral
            TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return MayProduceNil of _expr_.
        </emu-alg>
      </emu-clause>
      </ins>

    </emu-clause>

    <!-- es6num="12.2.2" -->
    <emu-clause id="sec-this-keyword">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-this-keyword">12.2.2</a>) The `this` Keyword</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.3" -->
    <emu-clause id="sec-identifier-reference">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-identifier-reference">12.2.3</a>) Identifier Reference</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.4" -->
    <emu-clause id="sec-primary-expression-literals">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-literals">12.2.4</a>) Literals</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.5" -->
    <emu-clause id="sec-array-initializer">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-array-initializer">12.2.5</a>) Array Initializer</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.6" -->
    <emu-clause id="sec-object-initializer">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-object-initializer">12.2.6</a>) Object Initializer</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.7" -->
    <emu-clause id="sec-function-defining-expressions">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-defining-expressions">12.2.7</a>) Function Defining Expressions</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.8" -->
    <emu-clause id="sec-primary-expression-regular-expression-literals">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-regular-expression-literals">12.2.8</a>) Regular Expression Literals</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.9" -->
    <emu-clause id="sec-template-literals">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-template-literals">12.2.9</a>) Template Literals</h1>
      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.2.10" -->
    <emu-clause id="sec-grouping-operator">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-grouping-operator">12.2.10</a>) The Grouping Operator</h1>

      <!-- es6num="12.2.10.1" -->
      <emu-clause id="sec-grouping-operator-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the lexical token sequence matched by |CoverParenthesizedExpressionAndArrowParameterList| cannot be parsed with no tokens left over using |ParenthesizedExpression| as the goal symbol.
          </li>
          <li>
            All Early Error rules for |ParenthesizedExpression| and its derived productions also apply to CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          </li>
        </ul>
      </emu-clause>

      <!-- es6num="12.2.10.2" -->
      <emu-clause id="sec-grouping-operator-static-semantics-isfunctiondefinition">
        <h1>Static Semantics: IsFunctionDefinition</h1>
        <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return IsFunctionDefinition of |Expression|.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.2.10.3" -->
      <emu-clause id="sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget">
        <h1>Static Semantics: IsValidSimpleAssignmentTarget</h1>
        <emu-see-also-para op="IsValidSimpleAssignmentTarget"></emu-see-also-para>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return IsValidSimpleAssignmentTarget of |Expression|.
        </emu-alg>
      </emu-clause>

      <ins class="block">
      <emu-clause id="sec-grouping-operator-static-semantics-mayproducenil">
        <h1>Static Semantics: MayProduceNil</h1>
        <emu-see-also-para op="MayProduceNil"></emu-see-also-para>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return MayProduceNil of |Expression|.
        </emu-alg>
      </emu-clause>
      </ins>

      <!-- es6num="12.2.10.4" -->
      <emu-clause id="sec-grouping-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredParenthesizedExpression of |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return the result of evaluating _expr_.
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return the result of evaluating |Expression|. This may be of type Reference.
        </emu-alg>
        <emu-note>
          <p>This algorithm does not apply GetValue to the result of evaluating |Expression|. The principal motivation for this is so that operators such as `delete` and `typeof` may be applied to parenthesized expressions.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>


  <!-- es6num="12.3" -->
  <emu-clause id="sec-left-hand-side-expressions">
    <h1>(<a href="https://tc39.github.io/ecma262/#sec-left-hand-side-expressions">12.3</a>) Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar>
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        <ins>MemberExpression[?Yield, ?Await]  OptionalChainingOperator `[` Expression[+In, ?Yield, ?Await] `]`</ins>
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        <ins>MemberExpression[?Yield, ?Await] OptionalChainingOperator IdentifierName</ins>
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        <ins>`new` MemberExpression[?Yield, ?Await] OptionalChainingOperator Arguments[?Yield, ?Await]</ins>

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget

      NewTarget :
        `new` `.` `target`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        <ins>MemberExpression[?Yield, ?Await] OptionalChainingOperator Arguments[?Yield]</ins>
        SuperCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        <ins>CallExpression[?Yield, ?Await] OptionalChainingOperator Arguments[?Yield, ?Await]</ins>
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        <ins>CallExpression[?Yield, ?Await] OptionalChainingOperator `[` Expression[+In, ?Yield, ?Await] `]`</ins>
        CallExpression[?Yield, ?Await] `.` IdentifierName
        <ins>CallExpression[?Yield, ?Await] OptionalChainingOperator IdentifierName</ins>
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await]

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>When processing an instance of the production <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:</p>
    <emu-grammar>
      CallMemberExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>

    <!-- es6num="12.3.1" -->
    <emu-clause id="sec-static-semantics">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-static-semantics">12.3.1</a>) Static Semantics</h1>

      <emu-clause id="sec-left-hand-side-expressions-static-semantics-coveredcallexpression">
        <h1>Static Semantics: CoveredCallExpression</h1>
        <emu-grammar>
          CallExpression : CoverCallExpressionAndAsyncArrowHead
        </emu-grammar>
        <emu-alg>
          1. Return the result of parsing the lexical token stream matched by |CoverCallExpressionAndAsyncArrowHead| using |CallMemberExpression| as the goal symbol with its <sub>[Yield]</sub> and <sub>[Await]</sub> parameters set to the values used when parsing |CoverCallExpressionAndAsyncArrowHead|.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.3.1.1" -->
      <emu-clause id="sec-static-semantics-static-semantics-contains">
        <h1>Static Semantics: Contains</h1>
        <p>With parameter _symbol_.</p>
        <emu-see-also-para op="Contains"></emu-see-also-para>
        <emu-grammar>
          MemberExpression :
            MemberExpression `.` IdentifierName
            <ins>MemberExpression OptionalChainingOperator IdentifierName</ins>
        </emu-grammar>
        <emu-alg>
          1. If |MemberExpression| Contains _symbol_ is *true*, return *true*.
          1. If _symbol_ is a |ReservedWord|, return *false*.
          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. If _symbol_ is the |ReservedWord| `super`, return *true*.
          1. If _symbol_ is a |ReservedWord|, return *false*.
          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>
          CallExpression :
            CallExpression `.` IdentifierName
            <ins>CallExpression OptionalChainingOperator IdentifierName</ins>
        </emu-grammar>
        <emu-alg>
          1. If |CallExpression| Contains _symbol_ is *true*, return *true*.
          1. If _symbol_ is a |ReservedWord|, return *false*.
          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.3.1.2" -->
      <emu-clause id="sec-static-semantics-static-semantics-isfunctiondefinition">
        <h1>Static Semantics: IsFunctionDefinition</h1>
        <emu-see-also-para op="IsFunctionDefinition"></emu-see-also-para>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            <ins>MemberExpression OptionalChainingOperator `[` Expression `]`</ins>
            MemberExpression `.` IdentifierName
            <ins>MemberExpression OptionalChainingOperator IdentifierName</ins>
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            <ins>`new` MemberExpression OptionalChainingOperator Arguments</ins>

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.3.1.3" -->
      <emu-clause id="sec-static-semantics-static-semantics-isdestructuring">
        <h1>Static Semantics: IsDestructuring</h1>
        <emu-see-also-para op="IsDestructuring"></emu-see-also-para>
        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>
        <emu-alg>
          1. If |PrimaryExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            <ins>MemberExpression OptionalChainingOperator `[` Expression `]`</ins>
            MemberExpression `.` IdentifierName
            <ins>MemberExpression OptionalChainingOperator IdentifierName</ins>
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            <ins>`new` MemberExpression OptionalChainingOperator Arguments</ins>

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.3.1.4" -->
      <emu-clause id="sec-static-semantics-static-semantics-isidentifierref">
        <h1>Static Semantics: IsIdentifierRef</h1>
        <emu-see-also-para op="IsIdentifierRef"></emu-see-also-para>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            <ins>MemberExpression OptionalChainingOperator `[` Expression `]`</ins>
            MemberExpression `.` IdentifierName
            <ins>MemberExpression OptionalChainingOperator IdentifierName</ins>
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            <ins>`new` MemberExpression OptionalChainingOperator Arguments</ins>

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.3.1.5" -->
      <emu-clause id="sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget">
        <h1>Static Semantics: IsValidSimpleAssignmentTarget</h1>
        <emu-see-also-para op="IsValidSimpleAssignmentTarget"></emu-see-also-para>
        <emu-grammar>
          CallExpression :
            CallExpression `[` Expression `]`
            CallExpression `.` IdentifierName
        </emu-grammar>
        <emu-alg>
          1. <ins>If MayProduceNil of |CallExpression| is *true*, return *false*.</ins>
          2. Return *true*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
        </emu-grammar>
        <emu-alg>
          1. <ins>If MayProduceNil of |MemberExpression| is *true*, return *false*.</ins>
          2. Return *true*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            SuperProperty
        </emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>
          CallExpression :
            CoverCallExpressionAndAsyncArrowHead
            <ins>MemberExpression OptionalChainingOperator Arguments</ins>
            SuperCall
            CallExpression Arguments
            <ins>CallExpression OptionalChainingOperator Arguments</ins>
            <ins>CallExpression OptionalChainingOperator `[` Expression `]`</ins>
            <ins>MemberExpression OptionalChainingOperator IdentifierName</ins>
            CallExpression TemplateLiteral

          NewExpression :
            `new` NewExpression

          MemberExpression :
            MemberExpression TemplateLiteral
            `new` MemberExpression Arguments
            <ins>`new` MemberExpression OptionalChainingOperator Arguments</ins>

          NewTarget :
            `new` `.` `target`
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <ins class="block">
      <emu-clause id="sec-static_semantics-static-semantics-mayproducenil">
        <h1>Static Semantics: MayProduceNil</h1>
        <emu-see-also-para op="MayProduceNil"></emu-see-also-para>
        <emu-grammar>
          MemberExpression :
            MemberExpression  OptionalChainingOperator `[` Expression `]`
            MemberExpression OptionalChainingOperator IdentifierName
            `new` MemberExpression OptionalChainingOperator Arguments

          CallExpression :
            MemberExpression OptionalChainingOperator Arguments
            CallExpression OptionalChainingOperator Arguments
            CallExpression OptionalChainingOperator `[` Expression `]`
            CallExpression OptionalChainingOperator IdentifierName
        </emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            SuperProperty
            MetaProperty

          CallExpression :
            SuperCall
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            `new` MemberExpression Arguments

          CallMemberExpression :
            MemberExpression Arguments
        </emu-grammar>
        <emu-alg>
          1. Return MayProduceNil of |MemberExpression|.
        </emu-alg>
        <emu-grammar>
          CallExpression :
            CallExpression Arguments
            CallExpression `[` Expression `]`
            CallExpression `.` IdentifierName
            CallExpression TemplateLiteral
        </emu-grammar>
        <emu-alg>
          1. Return MayProduceNil of |CallExpression|.
        </emu-alg>
        <emu-grammar>
          NewExpression :
            `new` NewExpression
        </emu-grammar>
        <emu-alg>
          1. Return MayProduceNil of |NewExpression|.
        </emu-alg>
      </emu-clause>
      </ins>
    </emu-clause>

    <!-- es6num="12.3.2" -->
    <emu-clause id="sec-property-accessors">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-property-accessors">12.3.2</a>) Property Accessors</h1>
      <emu-note>
        <p>Properties are accessed by name, using either the dot notation:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
          <br>
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>or the bracket notation:</p>
        <div class="rhs">
          |MemberExpression| `[` |Expression| `]`
          <br>
          |CallExpression| `[` |Expression| `]`
        </div>
        <p>The dot notation is explained by the following syntactic conversion:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
        </div>
        <p>is identical in its behaviour to</p>
        <div class="rhs">
          |MemberExpression| `[` &lt;<i>identifier-name-string</i>&gt; `]`
        </div>
        <p>and similarly</p>
        <div class="rhs">
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>is identical in its behaviour to</p>
        <div class="rhs">
          |CallExpression| `[` &lt;<i>identifier-name-string</i>&gt; `]`
        </div>
        <p>where &lt;<i>identifier-name-string</i>&gt; is the result of evaluating StringValue of |IdentifierName|.</p>
      </emu-note>

      <!-- es6num="12.3.2.1" -->
      <emu-clause id="sec-property-accessors-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be the result of evaluating |MemberExpression|.
          1. ReturnIfAbrupt(_baseReference_).
          1. <ins>If _baseReference_ is a Reference and IsNilReference(_baseReference_) is *true*, then</ins>
            1. <ins>Return _baseReference_.</ins>
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _propertyNameReference_ be the result of evaluating |Expression|.
          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).
          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).
          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyKey_, and whose strict reference flag is _strict_.
        </emu-alg>
        <ins class="block">
        <emu-grammar>MemberExpression : MemberExpression OptionalChainingOperator `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be the result of evaluating |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. If _baseValue_ is *undefined* or *null*, then
            1. Return a value of type Reference whose base value is ~Nil~.
          1. Let _propertyNameReference_ be the result of evaluating |Expression|.
          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).
          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).
          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyKey_, and whose strict reference flag is _strict_.
        </emu-alg>
        </ins>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be the result of evaluating |MemberExpression|.
          1. ReturnIfAbrupt(_baseReference_).
          1. <ins>If _baseReference_ is a Reference and IsNilReference(_baseReference_) is *true*, then</ins>
            1. <ins>Return _baseReference_.</ins>
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
          1. Let _propertyNameString_ be StringValue of |IdentifierName|.
          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyNameString_, and whose strict reference flag is _strict_.
        </emu-alg>
        <ins class="block">
        <emu-grammar>MemberExpression : MemberExpression OptionalChainingOperator IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be the result of evaluating |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. If _baseValue_ is *undefined* or *null*, then
            1. Return a value of type Reference whose base value is ~Nil~.
          1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
          1. Let _propertyNameString_ be StringValue of |IdentifierName|.
          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyNameString_, and whose strict reference flag is _strict_.
        </emu-alg>
        </ins>
        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
        <p>Is evaluated in exactly the same manner as <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar> except that the contained |CallExpression| is evaluated in step 1.</p>
        <ins class="block">
        <emu-grammar>CallExpression : CallExpression OptionalChainingOperator `[` Expression `]`</emu-grammar>
        <p>Is evaluated in exactly the same manner as <emu-grammar>MemberExpression : MemberExpression OptionalChainingOperator `[` Expression `]`</emu-grammar> except that the contained |CallExpression| is evaluated in step 1.</p>
        </ins>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <p>Is evaluated in exactly the same manner as <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar> except that the contained |CallExpression| is evaluated in step 1.</p>
        <ins class="block">
        <emu-grammar>CallExpression : CallExpression OptionalChainingOperator IdentifierName</emu-grammar>
        <p>Is evaluated in exactly the same manner as <emu-grammar>MemberExpression : MemberExpression OptionalChainingOperator IdentifierName</emu-grammar> except that the contained |CallExpression| is evaluated in step 1.</p>
        </ins>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.3.3" -->
    <emu-clause id="sec-new-operator">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-new-operator">12.3.3</a>) The `new` Operator</h1>

      <!-- es6num="12.3.3.1" -->
      <emu-clause id="sec-new-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>NewExpression : `new` NewExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateNew(|NewExpression|, ~empty~<ins>, false</ins>).
        </emu-alg>
        <emu-grammar>MemberExpression : `new` MemberExpression Arguments</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateNew(|MemberExpression|, |Arguments|<ins>, false</ins>).
        </emu-alg>
        <ins class="block">
        <emu-grammar>MemberExpression : `new` MemberExpression OptionalChainingOperator Arguments</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateNew(|MemberExpression|, |Arguments|, true).
        </emu-alg>
        </ins>

        <!-- es6num="12.3.3.1.1" -->
        <emu-clause id="sec-evaluatenew" aoid="EvaluateNew">
          <h1>Runtime Semantics: EvaluateNew ( _constructExpr_, _arguments_ <ins>, _optionalEvaluation_</ins>)</h1>
          <p>The abstract operation EvaluateNew with arguments _constructExpr_, _arguments_, <ins>and _optionalEvaluation_</ins> performs the following steps:</p>
          <emu-alg>
            1. Assert: _constructExpr_ is either a |NewExpression| or a |MemberExpression|.
            1. Assert: _arguments_ is either ~empty~ or an |Arguments|.
            1. Let _ref_ be the result of evaluating _constructExpr_.
            1. ReturnIfAbrupt(_ref_).
            1. <ins>If _ref_ is a Reference and IsNilReference(_ref_) is *true*, then</ins>
              1. <ins>Return _ref_.</ins>
            1. Let _constructor_ be ? GetValue(_ref_).
            1. <ins>If _optionalEvaluation_ is *true* and _constructor_ is *undefined* or *null*, then</ins>
              1. <ins>Return a value of type Reference whose base value is ~Nil~.</ins>
            1. If _arguments_ is ~empty~, let _argList_ be a new empty List.
            1. Else,
              1. Let _argList_ be ArgumentListEvaluation of _arguments_.
              1. ReturnIfAbrupt(_argList_).
            1. If IsConstructor(_constructor_) is *false*, throw a *TypeError* exception.
            1. Return ? Construct(_constructor_, _argList_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.3.4" -->
    <emu-clause id="sec-function-calls">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-function-calls">12.3.4</a>) Function Calls</h1>

      <!-- es6num="12.3.4.1" -->
      <emu-clause id="sec-function-calls-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>
        <emu-alg>
          1. Let _expr_ be CoveredCallExpression of |CoverCallExpressionAndAsyncArrowHead|.
          1. Let _memberExpr_ be the |MemberExpression| of _expr_.
          1. Let _arguments_ be the |Arguments| of _expr_.
          1. Let _ref_ be the result of evaluating _memberExpr_.
          1. Let _func_ be ? GetValue(_ref_).
          1. If Type(_ref_) is Reference, <ins>IsNilReference(_ref_) is *false*</ins>, IsPropertyReference(_ref_) is *false*, and GetReferencedName(_ref_) is `"eval"`, then
            1. If SameValue(_func_, %eval%) is *true*, then
              1. Let _argList_ be ? ArgumentListEvaluation(_arguments_).
              1. If _argList_ has no elements, return *undefined*.
              1. Let _evalText_ be the first element of _argList_.
              1. If the source code matching this |CallExpression| is strict mode code, let _strictCaller_ be *true*. Otherwise let _strictCaller_ be *false*.
              1. Let _evalRealm_ be the current Realm Record.
              1. Perform ? HostEnsureCanCompileStrings(_evalRealm_, _evalRealm_).
              1. Return ? PerformEval(_evalText_, _evalRealm_, _strictCaller_, *true*).
          1. If Type(_ref_) is Reference, then
            1. <ins>If IsNilReference(_ref_) is *true*, then</ins>
              1. <ins>Return _ref_.</ins>
            1. If IsPropertyReference(_ref_) is *true*, then
              1. Let _thisValue_ be GetThisValue(_ref_).
            1. Else the base of _ref_ is an Environment Record,
              1. Let _refEnv_ be GetBase(_ref_).
              1. Let _thisValue_ be _refEnv_.WithBaseObject().
          1. Else Type(_ref_) is not Reference,
            1. Let _thisValue_ be *undefined*.
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateDirectCall(_func_, _thisValue_, _arguments_, _tailCall_<ins>, false</ins>).
        </emu-alg>
        <p>A |CallExpression| evaluation that executes step 6.a.vii is a <dfn>direct eval</dfn>.</p>
        <ins class="block">
        <emu-grammar>CallExpression : MemberExpression OptionalChaining Arguments</emu-grammar>
        <p>Is evaluated in the same manner as <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>, except the three first steps, which are replaced by:
        <emu-alg>
          1. Let _memberExpr_ be the |MemberExpression| of |CallExpression|.
          1. Let _arguments_ be the |Arguments| of |CallExpression|.
        </emu-alg>
        <p>and the last step, which is replaced by:</p>
        <emu-alg>
          1. Return ? EvaluateDirectCall(_func_, _thisValue_, |Arguments|, _tailCall_, true).
        </emu-alg>
        </ins>
        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>
        <emu-alg>
          1. Let _ref_ be the result of evaluating |CallExpression|.
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_ref_, |Arguments|, _tailCall_<ins>, false</ins>).
        </emu-alg>
        <ins class="block">
        <emu-grammar>CallExpression : CallExpression OptionalChainingOperator Arguments</emu-grammar>
        <emu-alg>
          1. Let _ref_ be the result of evaluating |CallExpression|.
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_ref_, |Arguments|, _tailCall_, true).
        </emu-alg>
        </ins>
      </emu-clause>

      <!-- es6num="12.3.4.2" -->
      <emu-clause id="sec-evaluatecall" aoid="EvaluateCall">
        <h1>Runtime Semantics: EvaluateCall( _ref_, _arguments_, _tailPosition_<ins>, _optionalEvaluation_</ins> )</h1>
        <p>The abstract operation EvaluateCall takes as arguments a value _ref_, a  Parse Node _arguments_, a Boolean argument _tailPosition_, <ins>and a Boolean argument _optionalEvaluation_</ins>. It performs the following steps:</p>
        <emu-alg>
          1. Let _func_ be ? GetValue(_ref_).
          1. If Type(_ref_) is Reference, then
            1. <ins>If IsNilReference(_ref_), then</ins>
              1. <ins>Return _ref_.</ins>
            1. If IsPropertyReference(_ref_) is *true*, then
              1. Let _thisValue_ be GetThisValue(_ref_).
            1. Else the base of _ref_ is an Environment Record,
              1. Let _refEnv_ be GetBase(_ref_).
              1. Let _thisValue_ be _refEnv_.WithBaseObject().
          1. Else Type(_ref_) is not Reference,
            1. Let _thisValue_ be *undefined*.
          1. Return ? EvaluateDirectCall(_func_, _thisValue_, _arguments_, _tailPosition_<ins>, _optionalEvaluation_</ins>).
        </emu-alg>
      </emu-clause>

      <!-- es6num="12.3.4.3" -->
      <emu-clause id="sec-evaluatedirectcall" aoid="EvaluateDirectCall">
        <h1>Runtime Semantics: EvaluateDirectCall( _func_, _thisValue_, _arguments_, _tailPosition_<ins>, _optionalEvaluation_</ins> )</h1>
        <p>The abstract operation EvaluateDirectCall takes as arguments a value _func_, a value _thisValue_, a Parse Node _arguments_, a Boolean argument _tailPosition_, <ins>and a Boolean argument _optionalEvaluation_</ins>. It performs the following steps:</p>
        <emu-alg>
          1. <ins>If _optionalEvaluation_ is *true* and _func_ is *undefined* or *null*, then</ins>
            1. <ins>Return a value of type Reference whose base value is ~Nil~.</ins>
          1. Let _argList_ be ? ArgumentListEvaluation(_arguments_).
          1. If Type(_func_) is not Object, throw a *TypeError* exception.
          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
          1. If _tailPosition_ is *true*, perform PrepareForTailCall().
          1. Let _result_ be Call(_func_, _thisValue_, _argList_).
          1. Assert: If _tailPosition_ is *true*, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.
          1. Assert: If _result_ is not an abrupt completion, then Type(_result_) is an ECMAScript language type.
          1. Return _result_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.3.5" -->
    <emu-clause id="sec-super-keyword">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-super-keyword">12.3.5</a>) The `super` Keyword</h1>

      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.3.6" -->
    <emu-clause id="sec-argument-lists">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-argument-lists">12.3.6</a>) Argument Lists</h1>

      <p><i>(not modified)</i></p>
    </emu-clause>

    <!-- es6num="12.3.7" -->
    <emu-clause id="sec-tagged-templates">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-tagged-templates">12.3.7</a>) Tagged Templates</h1>
      <emu-note>
        <p>A tagged template is a function call where the arguments of the call are derived from a |TemplateLiteral| (<emu-xref href="#sec-template-literals"></emu-xref>). The actual arguments include a template object (<emu-xref href="#sec-gettemplateobject"></emu-xref>) and the values produced by evaluating the expressions embedded within the |TemplateLiteral|.</p>
      </emu-note>

      <!-- es6num="12.3.7.1" -->
      <emu-clause id="sec-tagged-templates-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>MemberExpression : MemberExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. Let _tagRef_ be the result of evaluating |MemberExpression|.
          1. Let _thisCall_ be this |MemberExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_tagRef_, |TemplateLiteral|, _tailCall_<ins>, false</ins>).
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. Let _tagRef_ be the result of evaluating |CallExpression|.
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_tagRef_, |TemplateLiteral|, _tailCall_<ins>, false</ins>).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.3.8" -->
    <emu-clause id="sec-meta-properties">
      <h1>(<a href="https://tc39.github.io/ecma262/#sec-meta-properties">12.3.8</a>) Meta Properties</h1>

      <p><i>(not modified)</i></p>
    </emu-clause>
  </emu-clause>

</emu-clause>



